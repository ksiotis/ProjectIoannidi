# Ανάπτυξη Λογισμικού για Πληροφοριακά Συστήματα 2020-2021 - Κ23α

Μέλη Ομάδας:
* Νάνας Ιωάννης 201700102
* Σιώτης Κωνσταντίνος 201700140

## PART 3
_______________
### Αποτελέσματα έρευνας:
Το κομμάτι της ταχύτητας εξαρτάται κατά κύριο λόγο από δύο τμήματα:
1. τμήμα είναι το διάβασμα των .json και η μορφοποίηση της πληροφορίας τους σε tf-idf:
    * Σε αυτό το κομμάτι δεν μπορούμε να αντλήσουμε πολλά δεδομένα καθώς δεν έγινε κάποια αλλαγή στον τρόπο που λειτουργούν
        ο json parser και οι δομές στις αποίες αποθηκεύεται η πληροφορία. Μια φορά χτήστικε η βάση και δεν υπήρχε διαθέσιμος χρόνος να δοκιμαστούν άλλα μοντέλα υλοποίησης.
2. τμημα ειναι το κομμάτι της μηχανικής μάθησης και συγκεκριμένα η εκπαίδευση του. Πραγματοποιείται logistic regression με mini-batch gradient descent και μέγεθος batch 512.
    * Εδώ με βάσει διάφορα αποτελέσματα, για σκοπούς ακρίβειας του μοντέλου προτείνεται learning rate (lr)= 0.3 με ποσοστό επιτυχών προβλέψεων 96.9969%. Άλλες δοκιμές έδειξαν τα εξής:
        * lr = 0.4 Accuracy = 95.7765%
        * lr = 0.35 Accuracy = 96.3103%
        * lr = 0.5 Accuracy = 94.5074%
        * lr = 0.2 Accuracy = 96.4882%
        * lr = 0.25 Accuracy = 95.8419%
    * Ο χρόνος εκτέλεσης, άλλαξε με την εισαγωγή των threads. Συγκεκριμένα κάθε job "σπάει" σε πολλαπλά tasks που φορτώνονται στον scheduler και κάθε νήμα αναλαμβάνει από ένα, το εκτελεί και παίρνει άλλο. Παρατηρήθηκε μείωση από ~5 λεπτά για την πλήρη εκτέλεση του προγράμματος στα ~2,5 σε 10 threads στα 3,4 GHz.
    * Λόγω αδυναμίας πραγματικής παραλληλοποίησης κάθε ξεχωριστής εργασίας του προγραμματος, αφού κάθε στάδιο εξαρτάται από το προηγούμενο, παραλληλοποιήθηκε κάθε στάδιο διαμοιράζοντας την κάθε εργασία στα threads (πχ. αντιγραφή ενός πίνακα τιμών ανά στήλη αντί για συμπλήρωση πολλών διαφορετικών πινάκων).
    Όπου υπήρχε κίνδυνος ο χρόνος εκτέλεσης να αυξηθεί λόγω υπερβολικών wait σε σημαφόρους, τα tasks ομαδοποιήθηκαν (πχ. αντί για ένα task για κάθε στήλη, ένα task για τις πρώτες ν στήλες, άλλο ένα για τις επόμενες ν κοκ.).
    Κάθε παραλληλοποιημένη εργασία που απαιτεί την προηγούμενή της, που είναι η πλειοψηφία, περιμένει σε condition variable να τελειώσουν όλα τα προηγούμενα task, και έτσι επίσης δεν σπαταλείται επεξεργαστική ισχύς στο main thread.


#### Εξήγηση διαδικασίας logistic regression (main.cpp:210και κάτω):
1. transform_csv_to_vector: Επιστρέφει μονοδιάστατο πίνακαμε τις πραγματικές τιμές των διανυσμάτων (0,1) και ταυτόχρονα σε έναν 2d matrix δημιουργεί τα διανύσματα που αναπαριστούν τις απόλυτες διαφορές των επιμέρους μεταβλητών κάθε αρχείου με βάση το tfidf.
2. shuffleRows: καλείται στον πίνακα training και επιστρέφειέναν άλλο matrix που περιέχει τις γραμμές του training  σε τυχαία σειρά και δημιουργεί έναν πίνακα στο subsetY το οποίο περιέχει τις πραγματικές τιμές με την αντίστοιχη σειρά.
3. rows: καλείται για να επιστρέψει ένα υποσύνολο γραμμών από έναν πίνακα ξεκινώντας από τη start έως την end
-1 το υποσύνολο αυτό αντιγράφεται σε έναν νέο matrix. Στην εργασία χρησιμοποιείται για να πάρουμε batch_size κομμάτια του πίνακα.
4. epoch: εκτελεί ένα iteration της epoch για το εκάστοτε τωρινό batch και ανανεώνει τα βάρη w με βάση τους τύπους των εκφωνήσεων. Αναλυτικότερα καλεί τις επιμέρους συναρτήσεις:
    * predict: επιστρέφει έναν μονοδιάστατο matrix διαστάσεων rows * 1 που περιέχει τιμές ανάμεσα σε 0 και 1 που αντιστοιχούν στις προβλέψεις του μοντέλου για την κάθε γραμμή του batch.
        * dot: εκτελεί ένα εσωτερικό γινόμενο ανάμεσα σε κάθε γραμμή του πίνακα και τα βάρη και τα αποθηκεύει σε έναν rows* 1 matrix, τον οποίο επιστρέφει.
        * sigmoid: δέχεται έναν matrix που πάει και περνάει όλες τις τιμές του από τη σιγμοειδή συνάρτηση σ(x)=0.5*x/(1+|x|)(η οποίασυμπεριφέρεται αρκετά παρόμοια με την 1/(1+e^-x) αλλά υπολογίζεται πολύ πιο γρήγορα) και τις αντικαθιστά. Δουλεύει δηλαδή στον ίδιο πίνακα.
    * gradient: επιστρέφει τα thetas που είναι οι μερικές παράγωγοι του Jacobian πίνακα με βάση τους τύπους στις εκφωνήσεις. Τα thetas είναι ένας μονοδιάστατος 1 * columns πίνακας, ένα για κάθε weight.(έχει γίνει λάθος καιο πίνακας που επιστρέφεται είναι rows * columns αλλά οι πράξεις γίνονται μόνο στην πρώτη γραμμή που χρειάζεται ενώ οι υπόλοιπες θέσεις παραμένουν 0 με αποτέλεσμα να μην υπάρχει λάθος εντέλει).Γίνεται σε δύο στάδια: υπολογισμός των αποκλίσεων των predicted values από τα y για κάθε γραμμή (από τον τύπο το ) και έπειτα το άθροισμα για κάθε στήλη.
5. compare: Συγκρίνει τις γνωστές τιμές με τις τιμές που προέβλεψε το μοντέλο και επιστρέφει το συνολικό cross entropy L των προβλέψεων.
6. accuracy: Επιστρέφει το ποσοστό % των σωστών προβλέψεων.

#### Για την κατανόηση λειτουργίας των threads, παραθέτουμε το παρακάτω παράδειγμα:

Παράδειγμα matrix::shuffleRows:
* Χρησιμοποιώ αυτό ως παράδειγμα παραλληλοποιημένης συνάρτησης διότι είναι το πιο απλό και εύκολο, με αποτέλεσμα να φαίνεται καθαρά το κομμάτι των threads. Η ιδέα των shuffleRows είναι ότι πάιρνει ένα τμήμα 2d matrix και αντιγράφει τις γραμμές (του τμήματος αυτού) σε έναν καινούργιο matrix. Το κομμάτι το οποίο παραλληλοποιείται εδώ, είναι το κομμάτι της αντιγραφής των γραμμών από τον δοσμένο submatrix στον καινούργιο ανακατεμένο. Το κομμάτι της επιλογής, του πως δηλαδή θα γίνει το ανακάτεμα, γίνεται στην αρχή της συνάρτησης, πριν απο την παραλληλοποίηση. Για να επιτευχθεί το threading, θα πρέπει να ξεκαθαρίσουμε στο κάθε thread τι δουλεία έχει να κάνει. Αυτό γίνεται με την function shuffleRowsThreads η οποία αναπαριστά και την δουλεια που θα κάνει το κάθε thread ξεχωριστά. Για κάθε γραμμή που πρέπει να αντιγραφεί, δημιουργείται και ένα αντίστοιχο task, το οποίο προστίθεται στην ουρά του scheduler. Ταυτόχρονα με αυτήν την διαδικασία, όλη την ώρα, τρέχει η mainThread, της οποίας ο ρόλος είναι να ενεργοποιεί/μοιράζει τα threads, ανάλογα με τα tasks της ουράς. Όταν λοιπόν όλα τα shuffleRowsThreads-tasks μπουν στην ουρά, η shuffleRows σταματάει μέχρι να δοθεί σήμα τερματισμού από όλα τα tasks τα οποία δημιούργησε και επιστρέφει τον ανακατεμένο matrix. 
* Ένας άλλος τρόπος παραλληλοποίησης είναι να αναλάβει κάθε thread την επεξεργασία μιας στήλης όπου αυτό μπορεί να γίνει παράλληλα πχ. στην updateWeightsEpochThreads όπου κάθε thread αναλαμβάνει να ανανεώσει ένα weight ανά task χρησιμοποιώντας τα thetas σύμφωνα με τον τύπο της εκφώνησης. Σε αυτήν την περίπτωση η παραλληλοποίηση ανά γραμμή πίνακα δεν έχει νόημα αφού τα βάρη w είναι μονοδιάστατος πίνακας 1 * columns, άρα επιτυγχάνεται παραλληλοποίηση ανά στήλη. 

#### Συγχρονισμός Threads 

Ο scheduler στον constructor του δημιουργεί 10 threads και τα βάζει να εκτελέσουν την thread_main. Σύμφωνα με αυτή, θα εκτελούνται συνέχεια μέχρι να εκτελεστεί ο destructor του scheduler. Κατά την εκτέλεση περιμένουν σε condition variable μέχρι η ουρά των task να περιέχει κάτι όποτε και το αποσπούν από την ουρά (threadsafe με χρήση του mutex της ουράς) και το εκτελούν καλώντας την συνάρτησή του, run. Παράλληλα, κάθε φορά που καλείται η addTask του scheduler, αφού προστεθεί το task στην ουρά, καλείται η signal στο condition variable για να ξυπνήσει ένα thread. Η διαδικασία διάσπασης μιας εργασίας σε jobs από τη μεριά του master thread είναι η εξής:(χρησιμοποιείται ως παράδειγμα η συνάρτηση dot)
1. αρχικοποίηση βοηθητικού counter των ενεργών tasks και του mutex 
```c++
    conditionVariable doneMutex;
    int doneCounter=0;
```
2. αρχικοποίηση των ορισμάτων της συνάρτησης για το task, τα args[0] και args[1] παραμένουν ίδια, τα υπόλοιπα αλλάζουν ανάλογα με τις ανάγκες της συνάρτησης
```c++
    for (int i = 0; i < rows; i++) {

        void **args = newvoid*[7];
        args[0] = &doneMutex;
        args[1] = &doneCounter;
        args[2] = newint(i);// delete inside
        args[3] = newint(columns);// delete inside
        args[4] = returnable->table;
        args[5] = a.table;
        args[6] = b.table;
```
3. μπλοκάρισμα του mutex του counter, είσοδος του task (thread safe), αύξηση του counter των ενεργών tasks, ξεμπλοκάρισμα του mutex του counter
```c++
        doneMutex.lock();// pass task to scheduler
        sch.addTask(new task(dotThread, (void *)args));
        doneCounter++;
        doneMutex.unlock();
    }
```
4. αναμονή του master thread μέχρι τα ενεργά tasks να γίνουν 0
```c++
    // wait for all tasks to finish
    doneMutex.lock();
    while (doneCounter > 0) {
        doneMutex.wait();
    }
    doneMutex.unlock();
    return returnable;
```

#### Από τη μεριά των threads:
1. στα πλαίσια της thread_main, ξυπνάει και αποσπάειένα task από την ουρά, εκτελεί τηνrun του που καλει dotThread(args)
2. απόσπαση των arguments για την εκτέλεση, διαφέρει ανάλογα τη λειτουργία 
```c++
void dotThread(void*arg) {
    //get arguments
    void **argv = (void **)arg;
    conditionVariable *cond = (conditionVariable *)argv[0];
    int *doneCounter = (int *)argv[1];
    int i = *(int *)argv[2];
    int columns = *(int *)argv[3];
    float **returntable = (float **)argv[4];
    float **atable = (float **)argv[5];
    float **btable = (float **)argv[6];
```
3. κύρια λειτουργία της συνάρτησης, διαφέρει ανάλογατη λειτουργία
```c++
    //main function
    for(int j = 0; j < columns; j++) {
        returntable[i][0] += atable[i][j] * btable[0][j];
    }
```
4. μείωση του counter των ενεργών tasks και signal του condition variable που περιμένει το master thread αν έγινε 0
```c++
    cond->lock();
    if(--(*doneCounter)!=0) {
        cond->unlock();
    }
    else {
        cond->unlock();
        cond->signal();
    }
```
5. διαγραφή των μη στατικών ορισμάτων
```c++
    delete (int *)argv[2];
    delete (int *)argv[3];
    delete[] argv;
}
```

## PART 2
_______________
Δομές Δεδομένων:
* Matrix: Ένας απλός δισδιάστατος πίνακας από floats, που κρατάει το μέγεθός του.

* Tf-Idf:
    * Η ιδέα είναι η εξής. Αξιοποίηση των hashtable ώστε να μην κρατάμε πολλή πληροφορία, αλλά και για γρήγορη προσπέλαση δεδομένων.
    * Υπαρχει η class Index που στην ουσία αρχειοθετεί IndexObject στοιχεια. Ένα IndexObject, αναπαριστά μία λέξη, την idf τιμη της, το Nt (οπως αναφέρεται στην εργασία) , αλλά και την θέση της λέξης στον tf-idf vector. (aka dimension)Οπότε, όταν θέλουμε να κατασκευάσουμε ενα διάνυσμα απο ένα json/id, για καθε λέξη του, ανατρέχουμε το Index.
    * Δόμηση των json:Όπως στο index, έτσι και για τα jsons αξιοποιούνται hashtables. Ένα json_index class "κρατάει" το id του και ενα hashtable με όλα τα json_indexObject classes που του ανοίκουν.json_indexObject κρατάει μια λεξη, ποσες φορές έχει εμφανιστεί στο json αυτο, και την TF τιμή του.
        Για προσπέλαση στα json_index classes αξιοποιείται η hashtable καθώς μπορεί γρήγορα να βρει αυτο που ψάχνει με αναζήτηση στο id.
    

* Logistic Regression: 
    * περιέχει 2 πίνακες που είναι τα βάρη της κάθε διάστασης στο tfidf και ένα bias. Χρησιμοποιούνται για την epoch που τα ανανεώνει με βάση τα αποτελέσματα της predict ακολουθώντας τους τύπους του μαθήματος.
    * Η epoch κάνει το training. Πιο συγκεκριμένα, θα εκτελεστεί μέχρι η διαφορά του κόστους με αυτό της προηγούμενης φοράς να γίνει μικρότερο του 1 ή 100 φορές, ό,τι γίνει νωρίτερα.
    * Χρησιμοποιείται batch gradient descent με μέγεθος batch 100 αλλά υπάρχει δυνατότητα και για stohastic.
    * Προκειμένου το μοντέλο να γίνει trained σε θετικές σχέσεις και να μην είναι biased, προπονείται στο αρχείο που εξάγεται με τις θετικές σχέσεις.
    * Υπάρχει δυνατότητα εξαγωγής όλων των παραμέτρων σε και φόρτωσης από αρχείο.

### Main:
***Η εξήγηση των Main προυποθέτει την κατανοηση του PART 1 (παρακάτω).***\
Αφού φτιαχτούν τα specs:
1. Χωρίζουμε το δωσμένο csv αρχείο σε training, validation και test Sets ανάλογα.
2. Δημιουργούμε τις tf-idf βάσεις ανατρέχοντας το training set.
3. Δημιουργούμε τους πίνακες των απολύτων διαφορών των διανυσμάτων που ζητούνται για κάθε data set(|id1-id2|).
4. Εκπαιδεύουμε την logistic regression με batch gradient descent.
5. Εξάγουμε τα predictions στο out_pred.csv αρχειο. Επίσης εξάγουμε το Index για το idf και το trained model στα index.csv και model.txt, ώστε να μπορόυν να αξιοποιηθούν στην predictmain.
6. Καθαρίζουμε τις βάσεις.

##### Τρόπος Εκτέλεσης:
    $ make
    $ ./master.out Specs_dataset Spec_pair.csv Output_file <buckets_number>


### Predict Main:
1. Δημιουργούμε τον classifier φορτώνοντάς τα στοιχεία του από αρχείο.
2. Δημιουργούμε τις tf-idf βάσεις φορτώνοντάς τες από αρχείο.
3. Δημιουργούμε τους πίνακες των απολύτων διαφορών των διανυσμάτων που ζητούνται για κάθε data set(|id1-id2|) από το αρχείο εισόδου.
4. Εξάγουμε τα predictions στο αρχείο εξόδου.

##### Τρόπος Εκτέλεσης:
    $ make predictmain
    $ ./predictmain.out Jsons_Path Spec_pair.csv_Path index_output_Filename model_ouput_Filename


### Software Testing:
Γενικά:
* Για την υλοποίηση των tests χρησιμοποιείται η βιβλιοθήκη acutest.
* Όλα τα tests βρίσκονται στον φάκελο Unit_tests.

Makefile:\
Μέσω της makefile δίνονται διάφορες δυνατότητες. Αυτές είναι:
* δημιουργία όλων των tests
```
    $ make
```
* δημιουργία του εκτελέσιμου προγράμματος του name_test.cpp
```
    $ make <test_name>
```
##### Τρόπος Εκτέλεσης:
```
    $ <executable_test>
```
### Παραδοχές:
* Θεωρούμε ότι η συνάρτηση f(x)=0.5x/1+|x|+0.5 παράγει αρκετά κοντινά αποτελέσματα με την σιγμοειδή αλλά ο υπολογισμός των τιμών της είναι ταχύτερος. Γι'αυτό και χρησιμοποιείται αντί εκείνης.

## PART 1
_______________
### Δομές Δεδομένων:
* include
    * list.hpp: Στην list.hpp περιέχεται ο αφαιρετικός τύπος μιας λίστας (με list nodes) που μπορούν να αποθηκεύουν δείκτη οποιουδήποτε τύπου με την χρήση Template.
    * avl.hpp: Δέντρο τύπου avl με δεδομένα δείκτες σε ό,τι χρειαζόμαστε.
    * hashtable.hpp: Hashtable για strings οπού τα δεδομένα αποθηκεύονται σε avl δέντρο για γρήγορη ταχύτητα αναζήτησης.
    * spec.hpp: Περιέχει spec και clique όπου spec("id", clique*) και clique(spec list). Αφού τα cliques έχουν δεδομένα σε λίστα, αξιοποιούνται οι συναρτήσεις της list.hpp (όπως merge δυο κόμβων)

### Γενικά:
* Τα specs αποθηκεύονται και ο τρόπος πρόσβασης τους είναι ο εξής: 
```c++
Hashtable (hashtab) -> avl_tree search
```
όπως επίσης και αποθηκεύονται σε λίστα (specContainer).\
Οι κλίκες(cliques) αποθηκεύονται επίσης σε λίστα (cliqueContainer).

### Main:
1. Αφού δεχτεί τα filenames που χρειάζεται και δημιουργήσει το hashtable και λίστες, διαβάζει τους φακέλους με τα .json αρχεία.
2. Κατά την ανάγνωση, δημιουργεί το id και δημιουργεί τα ανάλογα specs, cliques τα οποία μάλιστα και προσθέτει στις ανάλογες δομές (όπως αναφέρονται στην ενότητα "Δομές Δεδομένων").
3. Έπειτα, με την χρήση της βάσης, γίνεται η ανάγνωση του .csv την οποία συνοδεύει η ενοποίηση των κλικών όπου αυτές απαιτούνται.
4. Τέλος (πριν το καθάρισμα της μνήμης), γίνεται η εγγραφή των ζευγαριών specs (τα id δηλαδή αυτών) στο αρχείο της επιλογής του χρήστη.
        
##### Τρόπος Εκτέλεσης:
    $ make
    $ ./master.out Specs_dataset Spec_pair.csv Output_file <buckets_number>



### Software Testing:
Γενικά:
* Για την υλοποίηση των tests χρησιμοποιείται η βιβλιοθήκη acutest.
* Όλα τα tests βρίσκονται στον φάκελο Unit_tests.

Makefile:\
Μέσω της makefile δίνονται διάφορες δυνατότητες. Αυτές είναι:
* δημιουργία όλων των tests
```
    $ make
```
* δημιουργία του εκτελέσιμου προγράμματος του name_test.cpp
```
    $ make <test_name>
```
##### Τρόπος Εκτέλεσης:
```
    $ <executable_test>
```

### json Parser:
#### Δομές Δεδομένων:
Έχουν χρησιμοποιηθεί οι ακόλουθες κλάσεις:
* data που περιέχει το όνομα(key), αποτελεί την κλάση γονέα για τα:
    * property, περιέχει μια τιμή(value) και χρησιμοποιείται για να αποθηκεύσει την πληροφορία του κάθε json ζευγαριού "key":"value"
    * array, περιέχει μια λίστα από properties, χρησιμοποιείται για να αποθηκεύσει την πληροφορία "key" : ["prop1":"value1", "prop2":"value2", ...]
    * jsonObject που περιέχει μια λίστα από data, δηλαδή από properties και arrays και χρησιμοποιείται για να αποθηκεύσει κάθε μέλος του json
    * jsonParser που χειρίζεται το διάβασμα από το αρχείο και περιέχει flags, enumerations κ.α.

#### Διάβασμα αρχείου:
* Γίνεται έντονη χρήση από flags. Επειδή ακριβώς τα αρχεία .json δεν έχουν συγκεκριμένα lines, αξιοποιείται η ανάγνωση χαρακτήρα-χαρακτήρα.
* Μέσω switch και enum, πραγματοποιείται η αναγνώριση των χαρακτήρων και διαμορφώνουν είτε τα keys είτε τα values (ή και τις list από values).

#### Παραδοχές: 
* Θεωρούμε πως το κάθε json αρχείο δεν περιέχει συντακτικά λάθη.
* Θεωρούμε πως δεν υπάρχουν περισσότερα από 1(ένα) objects  πχ.{{}}. 
